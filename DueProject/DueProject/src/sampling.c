/*
* sampling.c
*
* Created: 2018-04-03 11:46:58
*  Author: Daniel
*/

#include <inttypes.h>
#include <asf.h>
#include "sampling.h"

uint32_t edges = 0;

/**
*  Interrupt handler for TC0 interrupt. Timer frequency corresponds to sample frequency.
*  Take one sample of input signal every time routine runs.
*/
void TC0_Handler(void)
{
	volatile uint32_t ul_dummy;
	
	/* Clear status bit to acknowledge interrupt */
	ul_dummy = tc_get_status(TC0, 0);	//The compare bit is cleared by reading the register, manual p. 915

	/* Avoid compiler warning */
	UNUSED(ul_dummy);
	
	/* Start sampling (i.e. convert one sample value) */
	adc_start(ADC);
}

/* Interrupt handler for PA14. In this routine the frequency of the input signal is determined.
 * We count TC_VALUES number of positive edges of the square wave. Then we count the average 
 * value of a cycle. The frequency is the inverse of the length of a period. We use following
 * formula to determine frequency:
 *
 * frequency = (MCK/2)/(top_to_low/(TC_VALUES-1))
 *
 * where  MCK/2 is the TC frequency (42 MHz), "top_to_low"-parameter is the interval value
 * of our measurement and TC_VALUES-1 is the number of cycles we average our frequency on.
 * 
 * FACTBOX: Measuring the period is generally more precise for relatively low frequency signals. The
 * resolution is provided by the number of timer counts between input signal transitions. We count the
 * number of time intervals (rising) in a fixed time interval of TC_VALUES cycles (defined in header file)
 * The signal is a square wave, generated by an external comparator with hysteresis, which has the same
 * frequency as an analog input signal whose frequency we want to measure. Measuring time interval
 * between two consecutive signal transitions with the timer is not as effective and does not yield as precise
 * results as measuring frequency by counting transitions over fixed, relatively short, intervals. A too noisy
 * input signal whose noise amplitude may exceed the hysteresis interval will cause erratic values.
 */
void pin_high_pulse_handler(const uint32_t id, const uint32_t index)
{
	static uint32_t frequency = 0;
	if ((id == ID_PIOA) && (index == PIO_PA14)){
		if (pio_get(PIOA, PIO_TYPE_PIO_INPUT, PIO_PA14))
		{
			if (edges < TC_VALUES)
			{
				tc_values[edges] = tc_read_cv(TC1, 1);
				edges++;
			}
			else
			{
				uint32_t top_to_low = tc_values[TC_VALUES-1]-tc_values[0];
				edges = 0;
				frequency = 42000000/(top_to_low/(TC_VALUES-1));
				printf("Frequency: %lu Hz\n", frequency);
			}
			
		}
	}
}


void init_pulse_pin(void)
{
	pmc_enable_periph_clk(ID_PIOA);
	pio_set_input(PIOA, PIO_PA14, PIO_PULLUP); // PA14 = pin 23
	pio_pull_up(PIOA, PIO_PA14, 0); //enable pull-down, when no input then input state is low
	pio_handler_set(PIOA, ID_PIOA, PIO_PA14, PIO_IT_EDGE, pin_high_pulse_handler);
	pio_enable_interrupt(PIOA, PIO_PA14);
	NVIC_EnableIRQ(PIOA_IRQn);
}

void TC1_init(void)
{
	/* Configure power management of timer clocks (ID_TC4 = channel 1 of TC1) */
	pmc_enable_periph_clk(ID_TC4);
	tc_init(TC1, 1, 0 | TC_CMR_CPCTRG);
	tc_start(TC1, 1);
}

